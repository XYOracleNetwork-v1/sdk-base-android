package network.xyo.core

import android.os.Debug
import android.util.Log

//this allows us to use guard to check for null on these object and
//conditionally execute code if they are null and returns a non-optional object
inline fun <T> T.guard(block: T.() -> Unit): T {
    if (this == null) block(); return this
}

open class XYBase {

    val tag: String
        get() {
            return classNameFromObject(this)
        }

    val now: Long
        get() {
            return System.currentTimeMillis()
        }

    val nowNano: Long
        get() {
            return System.nanoTime()
        }

    fun logInfo(message: String) {
        logInfo(this, message)
    }

    fun logExtreme(message: String) {
        logExtreme(this, message)
    }

    fun logError(message: String, debug: Boolean) {
        logError(this, message, debug)
    }

    fun logError(exception: Exception, debug: Boolean) {
        logError(this, exception, debug)
    }

    fun logStatus(message: String, debug: Boolean) {
        logError(this, message, debug)
    }

    fun logAction(action: String) {
        logAction(this, action)
    }

    companion object {

        fun classNameFromObject(objectToCheck: Any): String {
            val parts = objectToCheck.javaClass.kotlin.simpleName?.split('.') ?: return "Unknown"
            return parts[parts.lastIndex]
        }

        fun sourceNameFromAny(source: Any): String {
            return (source as? String) ?: classNameFromObject(source)
        }

        fun logError(source: Any, message: String, debug: Boolean) {
            Log.e(sourceNameFromAny(source), message)
            Log.e(sourceNameFromAny(source), Thread.currentThread().stackTrace?.contentToString()?.replace(", ", ",\r\n")
                    ?: "Unknown Thread")
            if (debug) {
                throw RuntimeException()
            }
        }

        private fun isDebug(): Boolean {
            return Debug.isDebuggerConnected()
        }

        //Any Handled Exceptions
        fun logError(source: Any, ex: Throwable) {
            logError(source, ex, false)
        }

        fun logError(source: Any, ex: Throwable, reThrow: Boolean) {
            Log.e(sourceNameFromAny(source), classNameFromObject(ex))
            Log.e(sourceNameFromAny(source), ex.stackTrace!!.contentToString().replace(", ", ",\r\n"))
            if (isDebug()) {
                if (reThrow) {
                    throw RuntimeException(ex)
                }
            }
        }

        //Errors are conditions that should not occur but did.  These can include bad states,
        //or failed internet calls for example
        fun logError(source: Any, function: String, message: String, debug: Boolean) {
            logError(source, "$function:$message:${Thread.currentThread().name}", true)
            if (debug && isDebug()) {
                throw RuntimeException()
            }
        }

        fun logError(source: Any, message: String) {
            logError(source, "$message:${Thread.currentThread().name}", true)
        }

        //Normal information used for debugging.  Items should be less noisy than Extreme items
        fun logInfo(source: Any, function: String, info: String) {
            Log.i(sourceNameFromAny(source), "$source:$function:$info:${Thread.currentThread().name}")
        }

        fun logInfo(source: Any, info: String) {
            Log.i(sourceNameFromAny(source), "$info:${Thread.currentThread().name}")
        }

        //Actions are events that are generated by the user, like pushing a button
        fun logAction(source: Any, action: String) {
            Log.i(sourceNameFromAny(source), action)
        }

        //Items that are very noisy should use Extreme Logging
        fun logExtreme(source: Any, message: String) {
            if (isDebug()) {
                Log.v(sourceNameFromAny(source), message)
            }
        }

        //Status are Large Scale Events, Such As Startup, or Shutdown,
        //that may or may not be a result of a user action
        fun logStatus(source: Any, status: String) {
            Log.i(sourceNameFromAny(source), "App Status: $status")
        }

    }

}