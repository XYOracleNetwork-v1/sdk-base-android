package network.xyo.core

import android.content.Context
import android.os.Debug
import android.util.Log

//this allows us to use guard to check for null on these object and
//conditionally execute code if they are null and returns a non-optional object
inline fun <T> T.guard(block: T.() -> Unit): T {
    if (this == null) block(); return this
}

open class XYBase {

    open val tag: String
        get() {
            val parts = this.javaClass.kotlin.simpleName!!.split('.')
            return parts[parts.lastIndex]
        }

    val now: Long
        get() {
            return System.currentTimeMillis()
        }

    val nowNano: Long
        get() {
            return System.nanoTime()
        }

    fun logInfo(message: String) {
        logInfo(tag, message)
    }

    fun logExtreme(message: String) {
        logExtreme(tag, message)
    }

    fun logError(message: String, debug: Boolean) {
        logError(tag, message, debug)
    }

    fun logException(exception: Exception, debug: Boolean) {
        logException(tag, exception, debug)
    }

    fun logStatus(message: String, debug: Boolean) {
        logError(tag, message, debug)
    }

    fun logAction(action: String) {
        logAction(tag, action)
    }

    companion object {

        private const val TAG = "XYBase"

        fun init(context: Context) {
            Log.i(TAG, "initialized")
        }

        fun logError(module: String, message: String, debug: Boolean) {
            Log.e(module, message)
            Log.e(module, Thread.currentThread()?.stackTrace?.contentToString()?.replace(", ", ",\r\n") ?: "Unknown Thread")
            if (debug) {
                throw RuntimeException()
            }
        }

        private fun isDebug(): Boolean {
            return Debug.isDebuggerConnected()
        }

        //Any Handled Exceptions
        fun logException(module: String, ex: Exception) {
            logException(module, ex)
        }

        fun logException(module: String, ex: Exception, reThrow: Boolean) {
            if (isDebug()) {
                if (reThrow) {
                    throw RuntimeException(ex)
                }
            }
        }

        //Errors are conditions that should not occur but did.  These can include bad states,
        //or failed internet calls for example
        fun logError(module: String, function: String, message: String, debug: Boolean) {
            logError(module, "$function:$message:${Thread.currentThread().name}", true)
            if (debug && isDebug()) {
                throw RuntimeException()
            }
        }

        fun logError(module: String, message: String) {
            logError(module, "$message:${Thread.currentThread().name}", true)
        }

        //Normal information used for debugging.  Items should be less noisy than Extreme items
        fun logInfo(module: String, function: String, info: String) {
            Log.i(module, "$module:$function:$info:${Thread.currentThread().name}")
        }

        fun logInfo(module: String, info: String) {
            Log.i(module, "$info:${Thread.currentThread().name}")
        }

        //Actions are events that are generated by the user, like pushing a button
        fun logAction(module: String, action: String) {
            Log.i(module, action)
        }

        //Items that are very noisy should use Extreme Logging
        fun logExtreme(module: String, message: String) {
            if (isDebug()) {
                Log.v(module, message)
            }
        }

        //Status are Large Scale Events, Such As Startup, or Shutdown,
        //that may or may not be a result of a user action
        fun logStatus(module: String, status: String) {
            Log.i(module, "App Status: $status")
        }

    }

}